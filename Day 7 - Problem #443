443. String Compression

Given an array of characters, compress it in-place.

The length after compression must always be smaller than or equal to the original array.

Every element of the array should be a character (not int) of length 1.

After you are done modifying the input array in-place, return the new length of the array.

 
Follow up:
Could you solve it using only O(1) extra space?

 
Example 1:

Input:
["a","a","b","b","c","c","c"]

Output:
Return 6, and the first 6 characters of the input array should be: ["a","2","b","2","c","3"]

Explanation:
"aa" is replaced by "a2". "bb" is replaced by "b2". "ccc" is replaced by "c3".
 

Example 2:

Input:
["a"]

Output:
Return 1, and the first 1 characters of the input array should be: ["a"]

Explanation:
Nothing is replaced.
 

Example 3:

Input:
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

Output:
Return 4, and the first 4 characters of the input array should be: ["a","b","1","2"].

Explanation:
Since the character "a" does not repeat, it is not compressed. "bbbbbbbbbbbb" is replaced by "b12".
Notice each digit has it's own entry in the array.
 

Note:

All characters have an ASCII value in [35, 126].
1 <= len(chars) <= 1000.



====================================================================================================



Thought: too messy
Code: Python
class Solution:
    def compress(self, chars: List[str]) -> int:
        count = -1  # count how many characters are in the chars
        idx_prev = 0
        
        for i in range(0, len(chars) - 1):
            # if the current character is not the same as the next character
            if chars[i] != chars[i+1]:
                if i == 0:
                    # if the change occurs at index 0, that means there is only first character is unique, nothing need to be replaced
                    count += 1
                elif chars[i-1] != chars[i]:
                    # if the character is unique
                    count, chars = self.replaceChar(count, chars, True, i, idx_prev)
                else:
                    # add count by two, move the character to the front and let the next element be the total number of the same character
                    count, chars = self.replaceChar(count, chars, False, i, idx_prev)
                idx_prev = i + 1
                    
        if len(chars) == 1:  # if the length of the chars is one, just add count by one. Nother needs to be replaced
            count += 1
        elif len(chars) != 0:
            # used to deal with the character at the end of the list
            if chars[-2] != chars[-1]:
                # if the character is unique
                count, chars = self.replaceChar(count, chars, True, len(chars)-1, idx_prev)
            else:
                count, chars = self.replaceChar(count, chars, False, len(chars)-1, idx_prev)
        
        return count + 1
    
    
    def replaceChar(self, count, chars, is_unique, i, idx_prev):
        # used to put the current character and its total amount to the front
        if is_unique:
            count += 1
            chars[count] = chars[i]
        else:
            total = (i - chars.index(chars[i], idx_prev) + 1)
            if total >= 10:
                count += 3
                chars[count-2] = chars[i]
                chars[count - 1] = str(total//10)
                chars[count] = str(total % 10)
            else:
                count += 2
                chars[count-1] = chars[i]
                chars[count] = str(total)
        return count, chars
                

