696. Count Binary Substrings

Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.

Substrings that occur multiple times are counted the number of times they occur.

Example 1:
Input: "00110011"
Output: 6
Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".

Notice that some of these substrings repeat and are counted the number of times they occur.

Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
Example 2:
Input: "10101"
Output: 4
Explanation: There are 4 substrings: "10", "01", "10", "01" that have equal number of consecutive 1's and 0's.
Note:

s.length will be between 1 and 50,000.
s will only consist of "0" or "1" characters.



====================================================================================================



Thought: Tried to do it in two for loop. First loop go over every single number in the input string, second loop go over every two elements. Used a count to see if the substring
has the same amount of zero's and one's, then used the first half of the substring to determine if the half of the substring only contains zero or one. However, this method is 
too slow.
Code: Python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        count = 0  # store the amount of substrings that satisfy the description of the problem
        
        for i in range(0, len(s)):
            for y in range(i + 2, len(s) + 1, 2):
                # if the numbers of zero and one in the string are the same, check if half of the string only contains zero or one
                if s[i:y].count("0") == s[i:y].count("1") and not (
                        "0" in s[i:i + ((y - i) // 2)] and "1" in s[i:i + ((y - i) // 2)]):
                    count += 1
        
        return count



====================================================================================================



Thought: Look for the place where the number changes. Keep track of the previous and current amount of consecutive numbers and add the fewer number to the variable count, when
encounter the next change of numbers. We add the fewer number becasue the number of substring that has the same amount of zero's and one's depend on ther fewer number. 
E.g: "00011". There are three zero's and two one's. We have "0011", and "01" substring that satisfy the problem.
Code: Python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        prev = 0  # store the total amount of the preivous number
        cur = 1  # store the total amount of the current number
        count = 0  # store the total amount of substrings
        
        for i in range(1, len(s)):
            if s[i - 1] != s[i]:  # if the number changes from zero to one or one to zero
                count += min(prev, cur)  # add the number of fewer number occurred
                prev = cur
                cur = 1
            else:
                cur += 1
        
        return count + min(prev, cur)



====================================================================================================



Thought: Same method but used a list to store the amount of each consecutive numbers first, and then add them to the final result
Code: Python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        groups = []  # number of each zero's and one's segments
        num = 1  # used to keep track the amount of the consecutive numbers
        count = 0  # final result
        
        for i in range(1, len(s)):
            if s[i-1] == s[i]:  # if the number does not change
                num += 1
            else:  # if the number changes, add the amount of consecutive numbers then reset amount to one
                groups.append(num)
                num = 1
        groups.append(num)  # add the last the amount for the group of consecutive numbers
        
        for i in range(1, len(groups)):  # add the smaller number to the count
            count += min(groups[i-1], groups[i])
        
        return count



====================================================================================================



Thought: Tried to use the split method to seperate the string to a list. To accomplish this. We used replace to add a whitesapce between every number change.
Code: Python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        # add a whitespace to where the number changes
        s = s.replace("01", "0 1")
        s = s.replace("10", "1 0")
        groups = [len(i) for i in s.split()]  # split the number according to the whitespace and get the length of each segment
        result = 0
        
        for i in range(1, len(groups)):
            # add the smaller length to the final result
            result += min(groups[i-1], groups[i])
        
        return result    



====================================================================================================



Thought: Same code as the privous one, but used map and list() instead of a for loop to get the list. This solution is much faster than the previous one. From sample 100ms 
submission in leetcode.
Code: Python
class Solution:
    def countBinarySubstrings(self, s: str) -> int:
        # add a whitespace to where the number changes
        s = s.replace("01", "0 1")
        s = s.replace("10", "1 0")
        groups = list(map(len, s.split()))  # split the number according to the whitespace and get the length of each segment
        result = 0
        
        for i in range(1, len(groups)):
            # add the smaller length to the final result
            result += min(groups[i-1], groups[i])
        
        return result    
